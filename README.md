# ðŸ§  Digital Design using Verilog (Day 1â€“7)

Welcome to my **Digital Design Repository**, a structured and hands-on collection of **Verilog HDL implementations** aimed at building a **strong foundation in digital logic and RTL design**.

This repository currently documents my progress from **basic Verilog modeling styles** to **fundamental combinational building blocks**, with a strong focus on **clear hardware thinking, simulation, and verification**.

---

## ðŸ‘¨â€ðŸ’» About Me

Iâ€™m **Kousik Kar**, an **Electronics and Communication Engineering (ECE)** undergraduate student at **Jadavpur University (Batch of 2028)**, with interests in **Digital Design, FPGA, VLSI systems**, and **AI/ML**.

My goal is to develop **robust RTL design fundamentals**â€”understanding not only *how* to write Verilog, but *why* the hardware works the way it doesâ€”while maintaining clean, modular, and synthesizable designs.

---

## ðŸŽ¯ Repository Purpose

This repository is intended to:

- Build a **systematic foundation** in Digital Design using Verilog HDL  
- Demonstrate how **digital logic theory translates into hardware**  
- Practice **industry-relevant Verilog modeling styles**  
- Emphasize **testbench-driven verification**
- Serve as a long-term reference for **FPGA and VLSI learning**

---

## ðŸ“˜ Progress Overview (Completed: Day 1â€“7)

### ðŸ”¹ Day 1: Behavioral Modeling in Verilog
- Continuous assignments and procedural blocks  
- Combinational `always @(*)` blocks  
- Synthesizable behavioral constructs  

---

### ðŸ”¹ Day 2: Structural and Gate-Level Modeling
- Hierarchical module instantiation  
- Built-in gate primitives (`and`, `or`, `xor`, etc.)  
- Understanding structural composition of logic  

---

### ðŸ”¹ Day 3: Switch-Level Modeling
- CMOS-based switch-level primitives  
- Modeling pull-up and pull-down networks  
- Relation between transistor-level and logic-level design  

---

### ðŸ”¹ Day 4: Logic Gates using Multiplexers
- Implementing AND, OR, NOT, XOR using multiplexers  
- Functional completeness of MUX-based logic  
- Comparison with direct gate implementations  

---

### ðŸ”¹ Day 5: Half Adder and Half Subtractor
- Boolean logic implementation  
- Truth-table verification  
- Dedicated testbench for functional validation  

---

### ðŸ”¹ Day 6: Full Adder and Full Subtractor
- Structural construction using half adders  
- Carry and borrow propagation logic  
- Exhaustive simulation-based verification  

---

### ðŸ”¹ Day 7: Universal Gate Design (NAND & NOR)
- Logic implementation using **NAND-only** gates  
- Logic implementation using **NOR-only** gates  
- Understanding universality and logic optimization  

---

## ðŸ§ª Verification Approach

For every completed module:
- A **dedicated testbench** is written  
- Simulation is used to verify **functional correctness**  
- Edge cases are tested wherever applicable  

Waveforms are generated to visually confirm expected behavior.

---

## ðŸ› ï¸ Tools Used

- Verilog HDL  
- Simulation tools (Vivado / Icarus Verilog + GTKWave)  
- VS Code for RTL development  



> âš ï¸ **Note:**  
> This repository reflects my learning journey step by step.  
> Only concepts that are **implemented, simulated, and understood** are documented.


